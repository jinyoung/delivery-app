Let's start by creating the `pom.xml` file which will define the Maven project, its dependencies, and properties.

pom.xml
```xml
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.example</groupId>
    <artifactId>delivery-management</artifactId>
    <version>1.0.0-SNAPSHOT</version>
    <packaging>jar</packaging>

    <name>delivery-management</name>
    <description>Delivery Management System</description>

    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.1.3</version>
    </parent>

    <properties>
        <java.version>17</java.version>
        <spring-cloud.version>2021.0.3</spring-cloud.version>
    </properties>

    <dependencies>
        <!-- Spring Boot Starter Web, includes RESTful application support -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>

        <!-- Spring Boot Starter Data JPA, includes spring-data-rest -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>

        <!-- H2 Database Engine -->
        <dependency>
            <groupId>com.h2database</groupId>
            <artifactId>h2</artifactId>
            <scope>runtime</scope>
        </dependency>

        <!-- Lombok for boilerplate code reduction -->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>

        <!-- Spring Cloud Stream with Kafka Binder -->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-stream</artifactId>
            <version>3.1.3</version>
        </dependency>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-stream-binder-kafka</artifactId>
        </dependency>

        <!-- Jakarta Persistence API -->
        <dependency>
            <groupId>jakarta.persistence</groupId>
            <artifactId>jakarta.persistence-api</artifactId>
        </dependency>

        <!-- Spring Boot Starter Test for testing -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>

        <!-- JUnit for unit testing -->
        <dependency>
            <groupId>org.junit.jupiter</groupId>
            <artifactId>junit-jupiter</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-dependencies</artifactId>
                <version>${spring-cloud.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>
</project>
```

Next, let's create the `run.sh` script to build and run the application.

run.sh
```sh
#!/bin/bash

# Exit on any error
set -e

# Build the project with Maven
mvn clean install --no-transfer-progress

# Run the application
mvn spring-boot:run --no-transfer-progress
```

Make sure to give execute permissions to the `run.sh` script:
```sh
chmod +x run.sh
```

Now, let's start implementing the Java classes based on the Event Storming Model provided.

First, we'll create the `Rider` aggregate root entity.

src/main/java/com/example/deliverymanagement/domain/Rider.java
```java
package com.example.deliverymanagement.domain;

import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import lombok.Getter;
import lombok.Setter;

@Entity
@Getter
@Setter
public class Rider {
    @Id
    private String riderId;
    private String name;
    private String phone;
}
```

Next, we'll create the `RiderRepository` interface.

src/main/java/com/example/deliverymanagement/repository/RiderRepository.java
```java
package com.example.deliverymanagement.repository;

import com.example.deliverymanagement.domain.Rider;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.rest.core.annotation.RepositoryRestResource;

@RepositoryRestResource(collectionResourceRel = "riders", path = "riders")
public interface RiderRepository extends JpaRepository<Rider, String> {
}
```

Now, let's define the commands and events.

src/main/java/com/example/deliverymanagement/command/AssignOrder.java
```java
package com.example.deliverymanagement.command;

import lombok.Value;

@Value
public class AssignOrder {
    String orderId;
    String riderId;
}
```

src/main/java/com/example/deliverymanagement/command/UpdateRider.java
```java
package com.example.deliverymanagement.command;

import lombok.Value;

@Value
public class UpdateRider {
    String riderId;
    String name;
    String phone;
}
```

src/main/java/com/example/deliverymanagement/event/OrderAssigned.java
```java
package com.example.deliverymanagement.event;

import lombok.Value;

@Value
public class OrderAssigned {
    String orderId;
    String riderId;
}
```

src/main/java/com/example/deliverymanagement/event/RiderUpdated.java
```java
package com.example.deliverymanagement.event;

import lombok.Value;

@Value
public class RiderUpdated {
    String riderId;
    String name;
    String phone;
}
```

Next, we'll create the service layer to handle the commands and publish events.

src/main/java/com/example/deliverymanagement/service/RiderService.java
```java
package com.example.deliverymanagement.service;

import com.example.deliverymanagement.command.AssignOrder;
import com.example.deliverymanagement.command.UpdateRider;
import com.example.deliverymanagement.domain.Rider;
import com.example.deliverymanagement.event.OrderAssigned;
import com.example.deliverymanagement.event.RiderUpdated;
import com.example.deliverymanagement.repository.RiderRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.messaging.MessageChannel;
import org.springframework.messaging.support.MessageBuilder;
import org.springframework.stereotype.Service;

@Service
public class RiderService {
    private final RiderRepository riderRepository;
    private final MessageChannel outputChannel;

    @Autowired
    public RiderService(RiderRepository riderRepository, MessageChannel outputChannel) {
        this.riderRepository = riderRepository;
        this.outputChannel = outputChannel;
    }

    public void assignOrder(AssignOrder command) {
        // Logic to assign an order to a rider
        // ...

        // Publish an event
        OrderAssigned event = new OrderAssigned(command.getOrderId(), command.getRiderId());
        outputChannel.send(MessageBuilder.withPayload(event).build());
    }

    public void updateRider(UpdateRider command) {
        // Logic to update rider information
        Rider rider = riderRepository.findById(command.getRiderId()).orElseThrow();
        rider.setName(command.getName());
        rider.setPhone(command.getPhone());
        riderRepository.save(rider);

        // Publish an event
        RiderUpdated event = new RiderUpdated(command.getRiderId(), command.getName(), command.getPhone());
        outputChannel.send(MessageBuilder.withPayload(event).build());
    }
}
```

We'll also need to configure the Kafka binder and message channels.

src/main/java/com/example/deliverymanagement/config/KafkaConfig.java
```java
package com.example.deliverymanagement.config;

import org.springframework.cloud.stream.annotation.EnableBinding;
import org.springframework.cloud.stream.messaging.Source;
import org.springframework.context.annotation.Configuration;

@Configuration
@EnableBinding(Source.class)
public class KafkaConfig {
}
```

Finally, let's create a simple test case for our `RiderService`.

src/test/java/com/example/deliverymanagement/service/RiderServiceTest.java
```java
package com.example.deliverymanagement.service;

import com.example.deliverymanagement.command.UpdateRider;
import com.example.deliverymanagement.domain.Rider;
import com.example.deliverymanagement.repository.RiderRepository;
import org.junit.jupiter.api.Test;
import org.mockito.ArgumentCaptor;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.messaging.MessageChannel;
import org.springframework.messaging.support.MessageBuilder;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.mockito.Mockito.*;

@SpringBootTest
public class RiderServiceTest {

    @Autowired
    private RiderService riderService;

    @Test
    public void testUpdateRider() {
        RiderRepository mockRiderRepository = mock(RiderRepository.class);
        MessageChannel mockOutputChannel = mock(MessageChannel.class);

        Rider rider = new Rider();
        rider.setRiderId("rider123");
        rider.setName("John Doe");
        rider.setPhone("1234567890");

        when(mockRiderRepository.findById("rider123")).thenReturn(java.util.Optional.of(rider));

        UpdateRider command = new UpdateRider("rider123", "Jane Doe", "0987654321");
        riderService = new RiderService(mockRiderRepository, mockOutputChannel);
        riderService.updateRider(command);

        ArgumentCaptor<Rider> riderArgumentCaptor = ArgumentCaptor.forClass(Rider.class);
        verify(mockRiderRepository).save(riderArgumentCaptor.capture());

        Rider updatedRider = riderArgumentCaptor.getValue();
        assertEquals("Jane Doe", updatedRider.getName());
        assertEquals("0987654321", updatedRider.getPhone());

        verify(mockOutputChannel).send(any(MessageBuilder.class).build());
    }
}
```

This concludes a fully working implementation.